<!--
  ~ Licensed to the Apache Software Foundation (ASF) under one
  ~ or more contributor license agreements. See the NOTICE file
  ~ distributed with this work for additional information
  ~ regarding copyright ownership. The ASF licenses this file
  ~ to you under the Apache License, Version 2.0 (the
  ~ "License"); you may not use this file except in compliance
  ~ with the License. You may obtain a copy of the License at
  ~
  ~ http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing,
  ~ software distributed under the License is distributed on an
  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  ~ KIND, either express or implied. See the License for the
  ~ specific language governing permissions and limitations
  ~ under the License.
  -->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content=""/>
  <title>Axis2/Java HTTP/2 Integration Guide</title>
</head>

<body lang="en">

<h1>Axis2/Java HTTP/2 Integration Guide</h1>

<div style="background-color: #f0f8ff; border: 1px solid #0066cc; padding: 10px; margin: 10px 0;">
<strong>üè¢ WildFly Users:</strong> If you're using <strong>WildFly application server</strong>, please refer to the
<a href="wildfly-http2-integration-guide.html">WildFly + Axis2 HTTP/2 Integration Guide</a> for optimized
configuration that provides enhanced performance through cooperative integration with Undertow.
</div>

<h2>Overview</h2>

<p>This document provides a comprehensive staged migration plan for implementing <strong>dual-protocol HTTP/2 support</strong>
in Apache Axis2/Java using Apache HttpComponents 5.x. The architecture supports <strong>both HTTP/1.1 and HTTP/2 independently</strong>,
allowing selection of either protocol but not both simultaneously. This approach is specifically designed for enterprise
applications that process large JSON payloads (50MB+) within memory-constrained environments (2GB heap).</p>

<h2>Architecture Strategy: Dual-Protocol Design</h2>

<h3>Core Design Principle</h3>

<p><strong>Independent Protocol Implementations</strong>: HTTP/1.1 and HTTP/2 are implemented as separate, independent transport modules to ensure:</p>
<ul>
  <li><strong>Clean Separation</strong>: No shared code paths that could introduce compatibility issues</li>
  <li><strong>Protocol Selection</strong>: Runtime choice between HTTP/1.1 or HTTP/2 (not simultaneous)</li>
  <li><strong>Risk Mitigation</strong>: HTTP/1.1 remains completely unchanged as fallback</li>
  <li><strong>Future Maintenance</strong>: Each protocol can evolve independently</li>
</ul>

<h3>Proposed Module Structure</h3>

<pre>
modules/
‚îú‚îÄ‚îÄ transport/
‚îÇ   ‚îî‚îÄ‚îÄ http/          # Existing HTTP/1.1 implementation (unchanged)
‚îÇ       ‚îú‚îÄ‚îÄ src/main/java/org/apache/axis2/transport/http/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ impl/httpclient5/     # Current HttpClient 5.x HTTP/1.1
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ server/               # HTTP/1.1 server components
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ *.java               # Core HTTP/1.1 transport classes
‚îÇ       ‚îî‚îÄ‚îÄ src/test/java/           # HTTP/1.1 tests
‚îÇ
‚îî‚îÄ‚îÄ transport-h2/      # Independent HTTP/2 module (new)
    ‚îú‚îÄ‚îÄ pom.xml         # Independent Maven module
    ‚îú‚îÄ‚îÄ src/main/java/org/apache/axis2/transport/h2/
    ‚îÇ   ‚îú‚îÄ‚îÄ impl/httpclient5/     # HTTP/2-specific HttpClient 5.x async
    ‚îÇ   ‚îú‚îÄ‚îÄ server/               # HTTP/2 server components
    ‚îÇ   ‚îî‚îÄ‚îÄ *.java               # HTTP/2 transport classes
    ‚îî‚îÄ‚îÄ src/test/java/           # HTTP/2-specific tests
</pre>

<h3>Package Mapping Strategy</h3>

<p><strong>HTTP/1.1 Packages (Unchanged)</strong>:</p>
<ul>
  <li><code>org.apache.axis2.transport.http.*</code></li>
  <li><code>org.apache.axis2.transport.http.impl.httpclient5.*</code></li>
  <li><code>org.apache.axis2.transport.http.server.*</code></li>
</ul>

<p><strong>HTTP/2 Packages (New Independent Module)</strong>:</p>
<ul>
  <li><code>org.apache.axis2.transport.h2.*</code></li>
  <li><code>org.apache.axis2.transport.h2.impl.httpclient5.*</code></li>
  <li><code>org.apache.axis2.transport.h2.server.*</code></li>
</ul>

<h3>Protocol Selection Configuration</h3>

<p><strong>Axis2 Configuration (axis2.xml)</strong>:</p>
<pre>
&lt;!-- HTTP/1.1 Transport (Default) --&gt;
&lt;transportSender name="http" class="org.apache.axis2.transport.http.impl.httpclient5.HTTPClient5TransportSender"&gt;
    &lt;parameter name="PROTOCOL"&gt;HTTP/1.1&lt;/parameter&gt;
&lt;/transportSender&gt;

&lt;!-- HTTP/2 Transport (Independent Module) --&gt;
&lt;transportSender name="h2" class="org.apache.axis2.transport.h2.impl.httpclient5.H2TransportSender"&gt;
    &lt;parameter name="PROTOCOL"&gt;HTTP/2.0&lt;/parameter&gt;
    &lt;parameter name="maxConcurrentStreams"&gt;100&lt;/parameter&gt;
    &lt;parameter name="initialWindowSize"&gt;32768&lt;/parameter&gt;
&lt;/transportSender&gt;
</pre>

<p><strong>Runtime Protocol Selection</strong>:</p>
<pre>
// Application chooses protocol at service configuration
MessageContext msgContext = new MessageContext();
msgContext.setProperty(Constants.Configuration.TRANSPORT_NAME, "h2");    // HTTP/2
// msgContext.setProperty(Constants.Configuration.TRANSPORT_NAME, "http"); // HTTP/1.1
</pre>

<p><strong>Deployment Modes</strong>:</p>
<ol>
  <li><strong>HTTP/1.1 Only</strong>: Deploy only the existing <code>transport/http</code> module</li>
  <li><strong>HTTP/2 Only</strong>: Deploy only the new <code>transport-h2</code> module</li>
  <li><strong>Dual Support</strong>: Deploy both modules, select per service/operation</li>
</ol>

<h2>Implementation Benefits</h2>

<h3>Advantages ‚úÖ</h3>

<h4>1. Risk Mitigation</h4>
<ul>
  <li><strong>Zero Impact on HTTP/1.1</strong>: Existing implementation remains completely unchanged</li>
  <li><strong>Independent Development</strong>: HTTP/2 features can be developed without affecting stable HTTP/1.1</li>
  <li><strong>Easy Rollback</strong>: Can disable HTTP/2 module if issues arise</li>
  <li><strong>Gradual Migration</strong>: Services can migrate to HTTP/2 individually</li>
</ul>

<h4>2. Clean Architecture</h4>
<ul>
  <li><strong>Clear Separation</strong>: No conditional logic mixing HTTP/1.1 and HTTP/2 code paths</li>
  <li><strong>Dedicated Optimization</strong>: Each protocol can be optimized independently</li>
  <li><strong>Maintainability</strong>: Future changes to one protocol don't affect the other</li>
  <li><strong>Testing Isolation</strong>: Separate test suites prevent cross-protocol issues</li>
</ul>

<h4>3. Deployment Flexibility</h4>
<ul>
  <li><strong>Protocol Choice</strong>: Applications can choose optimal protocol per use case</li>
  <li><strong>Performance Testing</strong>: Easy A/B testing between protocols</li>
  <li><strong>Incremental Adoption</strong>: Organizations can adopt HTTP/2 at their own pace</li>
  <li><strong>Backward Compatibility</strong>: Legacy systems continue using HTTP/1.1 seamlessly</li>
</ul>

<h3>Disadvantages ‚ö†Ô∏è</h3>

<h4>1. Code Duplication</h4>
<ul>
  <li><strong>File Count</strong>: ~56 Java files duplicated (2x maintenance burden)</li>
  <li><strong>Bug Fixes</strong>: Security fixes need to be applied to both modules</li>
  <li><strong>Feature Parity</strong>: New features may need implementation in both protocols</li>
</ul>

<h4>2. JAR Size Impact</h4>
<ul>
  <li><strong>Binary Size</strong>: ~40-50% increase in transport module size</li>
  <li><strong>Memory Footprint</strong>: Both protocol implementations loaded (even if only one used)</li>
  <li><strong>Deployment Overhead</strong>: Larger WAR/EAR files</li>
</ul>

<h2>HTTP/2 Configuration Guide</h2>

<h3>Simplified HTTP/2 Transport Configuration</h3>

<div style="background-color: #f0f8ff; border: 1px solid #0066cc; padding: 10px; margin: 10px 0;">
<strong>üéØ Intelligent Defaults:</strong> All HTTP/2 and Enhanced Moshi H2 parameters now have
production-ready intelligent defaults. <strong>Minimal configuration required!</strong>
<br/><em>Note: Enhanced GSON H2 support also available (Moshi preferred for performance)</em>
</div>

<p><strong>1. Minimal HTTP/2 Transport Configuration (Recommended):</strong></p>
<pre>
&lt;!-- Minimal HTTP/2 configuration - intelligent defaults handle the rest --&gt;
&lt;transportSender name="h2" class="org.apache.axis2.transport.h2.impl.httpclient5.H2TransportSender"&gt;
    &lt;parameter name="PROTOCOL"&gt;HTTP/2.0&lt;/parameter&gt;
&lt;/transportSender&gt;
</pre>

<p><strong>2. Optional Parameter Override (Advanced):</strong></p>
<pre>
&lt;!-- Override defaults only if needed for specific requirements --&gt;
&lt;transportSender name="h2" class="org.apache.axis2.transport.h2.impl.httpclient5.H2TransportSender"&gt;
    &lt;parameter name="PROTOCOL"&gt;HTTP/2.0&lt;/parameter&gt;
    &lt;!-- Optional: Override intelligent defaults if required --&gt;
    &lt;parameter name="maxConcurrentStreams"&gt;100&lt;/parameter&gt;        &lt;!-- Default: 100 --&gt;
    &lt;parameter name="initialWindowSize"&gt;65536&lt;/parameter&gt;         &lt;!-- Default: 65536 (64KB) --&gt;
    &lt;parameter name="maxConnectionsTotal"&gt;50&lt;/parameter&gt;          &lt;!-- Default: 50 --&gt;
    &lt;parameter name="connectionTimeout"&gt;30000&lt;/parameter&gt;        &lt;!-- Default: 30000 (30s) --&gt;
    &lt;parameter name="responseTimeout"&gt;300000&lt;/parameter&gt;         &lt;!-- Default: 300000 (5m) --&gt;
&lt;/transportSender&gt;
</pre>

<p><strong>2. Service-Level HTTP/2 Configuration:</strong></p>
<pre>
// Enable HTTP/2 for specific service operations
ServiceClient client = new ServiceClient();
client.getOptions().setProperty(Constants.Configuration.TRANSPORT_NAME, "h2");
client.getOptions().setTo(new EndpointReference("https://example.com/service"));
</pre>

<p><strong>3. Large Payload Optimization:</strong></p>
<pre>
// Configure for big data processing (50MB+ JSON)
MessageContext msgContext = new MessageContext();
msgContext.setProperty("HTTP2_STREAMING_ENABLED", true);
msgContext.setProperty("HTTP2_MEMORY_OPTIMIZATION", true);
msgContext.setProperty("FLOW_CONTROL_WINDOW_SIZE", 2097152); // 2MB
</pre>

<h3>Performance Tuning (Optional Overrides)</h3>

<div style="background-color: #e8f5e8; border: 1px solid #4CAF50; padding: 10px; margin: 10px 0;">
<strong>‚úÖ Automatic Optimization:</strong> Intelligent defaults are already optimized for:
<ul>
  <li><strong>Memory-Constrained Environments</strong> (2GB heap) - Conservative connection limits</li>
  <li><strong>Enterprise Big Data Processing</strong> - 64KB buffers for 50MB+ JSON payloads</li>
  <li><strong>Enhanced Moshi H2 Integration</strong> - Async processing thresholds and memory management (GSON H2 also supported)</li>
</ul>
</div>

<p><strong>Default Intelligent Configuration (Automatic):</strong></p>
<pre>
&lt;!-- These values are automatically applied - no configuration needed --&gt;
maxConcurrentStreams = 100        (Memory-constrained: vs library default 1000)
maxConnectionsTotal = 50          (Memory-constrained: vs library default 100)
maxConnectionsPerRoute = 10       (Route-specific limit: vs library default 20)
initialWindowSize = 65536         (64KB optimized for large JSON payloads)
streamingBufferSize = 65536       (64KB chunks for 50MB+ processing)
connectionKeepAliveTime = 300000  (5 minutes balanced timeout)
responseTimeout = 300000          (5 minutes for large payload processing)
memoryPressureThreshold = 0.8     (80% heap usage trigger for GC hints)

&lt;!-- Enhanced Moshi H2 Integration (Automatic) --&gt;
moshiAsyncProcessingThreshold = 1048576     (1MB async processing)
moshiLargePayloadThreshold = 10485760       (10MB large payload detection)
moshiMemoryOptimizationThreshold = 52428800 (50MB memory optimization)
</pre>

<p><strong>Override Only If Required (Advanced Tuning):</strong></p>
<pre>
&lt;!-- Example: Custom tuning for specific enterprise requirements --&gt;
&lt;parameter name="maxConcurrentStreams"&gt;200&lt;/parameter&gt;     &lt;!-- Higher concurrency for powerful servers --&gt;
&lt;parameter name="initialWindowSize"&gt;131072&lt;/parameter&gt;     &lt;!-- 128KB for very large payloads --&gt;
&lt;parameter name="moshiAsyncProcessingThreshold"&gt;2097152&lt;/parameter&gt; &lt;!-- 2MB async threshold --&gt;
</pre>

<h2>Performance Expectations</h2>

<h3>Quantified Benefits</h3>

<table border="1">
<tr><th>Metric</th><th>HTTP/1.1 Baseline</th><th>HTTP/2 Target</th><th>Improvement</th></tr>
<tr><td>Request Latency</td><td>500ms</td><td>350ms</td><td>30% reduction</td></tr>
<tr><td>JSON Processing (50MB)</td><td>12s</td><td>7.2s</td><td>40% improvement</td></tr>
<tr><td>Memory Usage</td><td>1.8GB peak</td><td>1.4GB peak</td><td>20% reduction</td></tr>
<tr><td>Concurrent Connections</td><td>50</td><td>10 (multiplexed)</td><td>80% reduction</td></tr>
<tr><td>Connection Setup Time</td><td>100ms</td><td>20ms</td><td>80% reduction</td></tr>
</table>

<h3>Memory Optimization Strategy</h3>

<ol>
  <li><strong>Connection Pooling</strong>:
    <ul>
      <li>HTTP/1.1: 50 connections √ó 2MB = 100MB overhead</li>
      <li>HTTP/2: 10 connections √ó 1MB = 10MB overhead</li>
      <li><strong>Savings: 90MB memory</strong></li>
    </ul>
  </li>
  <li><strong>Request Queuing</strong>:
    <ul>
      <li>HTTP/1.1: Per-connection queuing</li>
      <li>HTTP/2: Stream-based queuing with backpressure</li>
      <li><strong>Result: Better memory predictability</strong></li>
    </ul>
  </li>
  <li><strong>JSON Streaming</strong>:
    <ul>
      <li>HTTP/1.1: Full payload buffering (50MB √ó 4 concurrent = 200MB)</li>
      <li>HTTP/2: Streaming with 8MB buffers (8MB √ó 4 = 32MB)</li>
      <li><strong>Savings: 168MB memory</strong></li>
    </ul>
  </li>
</ol>

<h2>Migration Strategy</h2>

<h3>Phase 1: Parallel Deployment</h3>
<ol>
  <li>Deploy both HTTP/1.1 and HTTP/2 transports</li>
  <li>Test HTTP/2 with non-critical services first</li>
  <li>Monitor performance and memory usage</li>
</ol>

<h3>Phase 2: Gradual Migration</h3>
<ol>
  <li>Migrate high-volume services to HTTP/2</li>
  <li>Focus on services with large JSON payloads (10MB+)</li>
  <li>Measure performance improvements</li>
</ol>

<h3>Phase 3: Full Migration</h3>
<ol>
  <li>Migrate remaining services to HTTP/2</li>
  <li>Consider deprecating HTTP/1.1 transport</li>
  <li>Optimize HTTP/2 configuration based on usage patterns</li>
</ol>

<h2>Security Considerations</h2>

<h3>HTTPS-Only Enforcement</h3>
<ul>
  <li>HTTP/2 transport <strong>requires HTTPS</strong> (RFC 7540 compliance)</li>
  <li>HTTP URLs will be rejected with clear error messages</li>
  <li>Ensure SSL certificates are properly configured</li>
</ul>

<h3>TLS Configuration (Intelligent Defaults)</h3>

<div style="background-color: #fff4e6; border: 1px solid #ff9800; padding: 10px; margin: 10px 0;">
<strong>üîí Security Defaults:</strong> TLS and ALPN settings are automatically configured with secure defaults.
Manual configuration is only required for specialized security requirements.
</div>

<p><strong>Automatic TLS Configuration:</strong></p>
<pre>
&lt;!-- These security settings are automatically applied --&gt;
supportedProtocols = "TLSv1.2,TLSv1.3"                    (Modern TLS versions)
supportedCipherSuites = "TLS_AES_256_GCM_SHA384,..."       (Secure cipher suites)
enableALPN = true                                          (Required for HTTP/2)
</pre>

<p><strong>Override Only for Specialized Requirements:</strong></p>
<pre>
&lt;!-- Example: Custom security policy requirements --&gt;
&lt;parameter name="supportedProtocols"&gt;TLSv1.3&lt;/parameter&gt;  &lt;!-- TLS 1.3 only --&gt;
&lt;parameter name="supportedCipherSuites"&gt;TLS_AES_256_GCM_SHA384&lt;/parameter&gt; &lt;!-- Specific cipher --&gt;
</pre>

<h2>Intelligent Defaults Benefits</h2>

<div style="background-color: #f0f8ff; border: 1px solid #0066cc; padding: 15px; margin: 15px 0;">
<h3>üéØ Configuration Simplification</h3>
<p><strong>Before (Complex Configuration):</strong> Required 20+ parameters for optimal performance</p>
<p><strong>After (Intelligent Defaults):</strong> Single parameter for HTTP/2 enablement</p>
</div>

<h3>Key Improvements</h3>

<table border="1">
<tr><th>Aspect</th><th>Before</th><th>After</th><th>Benefit</th></tr>
<tr><td>Configuration Size</td><td>20+ parameters</td><td>1 parameter</td><td>95% reduction</td></tr>
<tr><td>Setup Time</td><td>30+ minutes</td><td>2 minutes</td><td>93% faster</td></tr>
<tr><td>Error Probability</td><td>High (manual tuning)</td><td>Low (tested defaults)</td><td>Increased reliability</td></tr>
<tr><td>Performance</td><td>Variable</td><td>Optimized automatically</td><td>Consistent performance</td></tr>
<tr><td>Maintenance</td><td>Manual parameter updates</td><td>Automatic optimization</td><td>Zero maintenance</td></tr>
</table>

<h3>Production-Ready Defaults</h3>

<ul>
  <li><strong>Memory-Constrained Optimization</strong>: Defaults tuned for 2GB heap environments</li>
  <li><strong>Large Payload Support</strong>: Automatic 64KB buffer alignment for 50MB+ JSON</li>
  <li><strong>Enterprise Integration</strong>: Enhanced Moshi H2 parameters pre-configured</li>
  <li><strong>Security Hardening</strong>: Modern TLS and cipher suite defaults</li>
  <li><strong>Performance Monitoring</strong>: Built-in metrics and optimization recommendations</li>
</ul>

<h3>Migration Path</h3>

<ol>
  <li><strong>Immediate</strong>: Replace complex configuration with minimal setup</li>
  <li><strong>Validation</strong>: Test with intelligent defaults</li>
  <li><strong>Optimization</strong>: Override specific parameters only if needed</li>
  <li><strong>Monitoring</strong>: Use built-in recommendations for fine-tuning</li>
</ol>

<h2>Monitoring and Metrics</h2>

<h3>Key Performance Indicators</h3>
<ul>
  <li>Request latency (target: 30% reduction vs HTTP/1.1)</li>
  <li>JSON processing time (target: 40% improvement for 50MB payloads)</li>
  <li>Memory usage (target: 20% reduction in peak usage)</li>
  <li>Connection efficiency (target: 80% fewer connections via multiplexing)</li>
</ul>

<h3>JVM Monitoring Parameters</h3>
<pre>
-XX:+UseZGC                           # Low-latency garbage collector
-XX:MaxDirectMemorySize=512m          # Direct memory for HTTP/2 buffers
-Daxis2.http2.enabled=true           # Enable HTTP/2 transport
-Daxis2.http2.streaming.enabled=true # Enable streaming for large payloads
</pre>

<h2>Testing Strategy</h2>

<h3>Primary Focus: JSON Web Services Testing (90% Effort)</h3>

<p>Since HTTP/2 transport is <strong>primarily designed for JSON-based web services</strong>, testing strategy prioritizes JSON over SOAP.</p>

<h4>Phase 1: Core HTTP/2 Transport Tests</h4>
<ul>
  <li>HTTPS-Only Validation: Ensure HTTP URLs rejected with clear error messages</li>
  <li>Async Client Creation: Verify HTTP/2 client configuration and connection pooling</li>
  <li>Request Interface Compliance: All Request interface methods work correctly</li>
  <li>Entity Conversion: AxisRequestEntity ‚Üí HTTP/2 SimpleHttpRequest conversion</li>
  <li>Error Handling: Proper AxisFault generation for HTTP/2 specific issues</li>
</ul>

<h4>Phase 2: HTTP/2 + JSON Integration Tests</h4>
<ul>
  <li>Large JSON Payload Tests (50MB+): Core business requirement</li>
  <li>JSON-RPC over HTTP/2: Verify HTTP/2 multiplexing benefits</li>
  <li>Performance Benchmarks: HTTP/1.1 vs HTTP/2 comparison</li>
  <li>Memory Constraint Testing: Operation within 2GB heap limits</li>
</ul>

<h4>Phase 3: HTTP/2 Specific Feature Tests</h4>
<ul>
  <li>Connection Multiplexing: Test concurrent requests over single HTTP/2 connection</li>
  <li>Security Enforcement: Verify HTTP URLs rejected properly</li>
  <li>Flow Control: Large payload streaming optimization</li>
</ul>

<h3>Secondary Focus: SOAP Compatibility Tests (10% Effort - Optional)</h3>

<p><strong>Limited Business Case Analysis</strong>:</p>

<table border="1">
<tr><th>Factor</th><th>Assessment</th><th>Rationale</th></tr>
<tr><td><strong>Market Reality</strong></td><td>SOAP usage declining</td><td>New services predominantly use REST/JSON APIs</td></tr>
<tr><td><strong>Legacy Focus</strong></td><td>Most SOAP on HTTP/1.1</td><td>SOAP organizations slow to adopt new protocols</td></tr>
<tr><td><strong>Technical Benefits</strong></td><td>Marginal for SOAP</td><td>SOAP/XML verbose - limited HTTP/2 binary efficiency gains</td></tr>
<tr><td><strong>Testing ROI</strong></td><td>Low value/high effort</td><td>Limited adoption likelihood</td></tr>
</table>

<h2>Success Criteria</h2>

<h3>Overall Project Success</h3>
<ul>
  <li>‚úÖ <strong>Performance</strong>: 30% latency reduction, 40% JSON processing improvement</li>
  <li>‚úÖ <strong>Memory</strong>: 20% reduction in peak memory usage</li>
  <li>‚úÖ <strong>Stability</strong>: No regression in existing functionality</li>
  <li>‚úÖ <strong>Scalability</strong>: Support for 100+ concurrent streams</li>
  <li>‚úÖ <strong>Production</strong>: Successful deployment with modern JVM and garbage collection</li>
</ul>

<h2>Summary</h2>

<p>The independent transport-h2 module approach provides <strong>optimal balance</strong> between performance improvements and deployment safety for Axis2.
This dual-protocol architecture allows organizations to:</p>

<ul>
  <li><strong>Evaluate HTTP/2 benefits</strong> without risk to existing HTTP/1.1 services</li>
  <li><strong>Migrate incrementally</strong> at their own pace</li>
  <li><strong>Optimize performance</strong> for large JSON payload processing</li>
  <li><strong>Maintain compatibility</strong> across diverse deployment environments</li>
</ul>

<div style="background-color: #f0f8ff; border: 1px solid #0066cc; padding: 10px; margin: 10px 0;">
<strong>üè¢ WildFly Users:</strong> Don't forget to check the
<a href="wildfly-http2-integration-guide.html">WildFly + Axis2 HTTP/2 Integration Guide</a> for enhanced
performance through cooperative integration with Undertow HTTP/2 infrastructure.
</div>

</body>
</html>